---
layout: post
title: 간단한 프로토콜 HTTP
excerpt: "헤더정보, GET, POST, HEAD등 메소드에 대한 설명 그리고 쿠키"
categories: [network]
comments: true
---

TCP/IP의 많은 프로토콜과 마찬가지로 HTTP도 클라이언트와 서버간에 통신을 한다.<br>
텍스트, 이미지같은 리소스를 요청하는 쪽이 **클라이언트**고 요청한 리소스를 제공하는 쪽이 **서버**가 된다.

HTTP통신을 사용해 2대의 컴퓨터 간에 통신을 하는 경우 반드시 한쪽은 클라이언트가 되고 다른 쪽은 서버가 된다.

**HTTP는 클라이언트와 서버의 역할을 명확하게 구별한다.**

HTTP는 클라이언트로부터 **리퀘스트(요청,request)**가 송신되고 그 결과는 서버로부터 **리스폰스(응답,response)**되어 돌아온다.<br>
클라이언트로 부터 통신이 시작되며 서버에서는 리퀘스트를 받지 않고서는 리스폰스를 송신하는 일은 없다.

{% highlight html %}
<!-- 요청 헤더 -->
GET /test/test.html HTTP/1.1
Accept: */*
Accept-Language: ko
If-Modified-Since: Tue, 15 Jul 2019 09:31:13 GMT
If-None-Match: "734237e186acc61:a1b"
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36
Host: localhost
{% endhighlight %}

#### GET /test/test.html HTTP/1.1
요청 메소드. 요청 리소스 정보, http 버전

**GET** : 리퀘스트 URI로 식별된 리소스를 가져오도록 요청<br>
**POST** : 서버가 클라이언트의 폼 입력 필드 데이터의 수락을 요청. 클라이언트는 서버로 HTTP Body에 Data를 전송<br>
**HEAD** : 문서의 헤더 정보를 요청. GET과 같은 기능이지만 메세지 바디는 받지 않는다.<br>
**PUT** : 클라이언트가 전송한 데이터를 지정한 URI에 보존하도록 요청한다.<br>
**DELETE** : 클라이언트가 지정한 URI를 서버에서 삭제한다.<br>
**TRACE** : 클라이언트가 요청한 리소스에 도착하기까지의 경로를 기록하는 검사용 메소드. 중간에 거쳐가는 프록시나 게이트웨이의 중간 경로부터 최종 서버까지의 경로를 알아낼때 사용.

#### Accept
클라이언트가 허용할 수 있는 파일 형식(MIME TYPE)으로 */*은 특정 유형이 아닌 모든 파일형식을 지원한다는 의미가 됩니다.

#### User-Agent
클라이언트 소프트웨어의 이름, 버전등을 나타낸다.

#### If-Modified-Since
페이지가 수정되었을때 최신 버전의 페이지 요청을 위한 필드, 요청한 파일이 이 필드에 지정된 시간 이후로 변경되지 않는다면 서버로부터 데이터를 전송받지 않는다.

#### Accept-Encoding
클라이언트가 인식할 수 있는 인코딩을 명시

<hr>

{% highlight html %}
<!-- 리스폰스 송신 -->
HTTP/1.1 200 OK
Server: nginx
Date: Fri, 21 Jul 2006 05:32:01 GMT
Content-Type: text/html
Last-Modified: Fri, 21 Jul 2006 05:31:52 GMT
{% endhighlight %}

#### HTTP/1.1 200 OK
HTTP 버전과 응답 코드(200 성공)

#### Server
웹서버 정보를 나타낸다. 위 에서는 Nginx

#### Content-TYPE
요청한 파일의 MIME 타입을 나타낸다. text/html는 text중의 html파일임을 명시.

<hr>

### 쿠키

**HTTP는 스테이트리스 프로토콜**이다. 즉 요청,응답의 상태를 유지하지 않는다.<br>
장점 : 서버의 CPU, 메모리 리소스의 소비를 억제할 수 있다. 추가로 단순한 프로토콜이기에 다양한 곳에서 이용될 수 있다.<br>
단점 : 과거 상태를 참고로 리퀘스트를 처리할 수 없다.

사용자인증을 예로 들면, 어떤 페이지에서 로그인후 새 페이지로 이동을 했을 때 로그인 정보를 잃어버린다. 따라서 리퀘스트 시 매개변수나 추가정보를 붙여서 요청을 계속해야하는 상황이 발생할 수 있다.

위의 문제를 해결하기 위해 나온것중 하나가 **쿠키(cookie)이다.**

쿠키는 요청과 응답시 쿠키 정보를 추가해 클라이언트의 상태를 파악하기위한 시스템이다.<br>
헤더의 Set-Cookie라는 헤더 필드에의해 자동으로 쿠키값을 넣어서 송신한다.<br>
서버는 클라이언트가 보내온 쿠키를 확인해서 어느 클라이언트가 접속했는지 체크하고 서버상의 기록을 확인해서 이전상태를 알 수 있게된다.

하지만 쿠키는 탈취의 위험이 크므로 중요한 정보를 저장해서 사용하면 안된다.

<hr>

### 번외1 : 아스키와 바이너리 MIME
- 컴퓨터는 0과 1로 이뤄진 이진수만 이해한다.
- 컴퓨터에서는 ㄱ,ㄴ,ㄷ / a,b,c,d 등의 문자를 표시하려면 각각의 문자를 숫자로 지정해줄 필요가 있다. (a는 십진수로 97, z는 122 이런식의 규약) 규정된값을 이진수로 변환해서 컴퓨터가 각 문자를 식별할 수 있기 때문이다.
- 컴퓨터 등장 초기 공통된 표준이 없어 각자 자기 식으로 하드웨어를 제작하고 소프트웨어를 개발했다. 표준이 없었다.
- **ANSI**라는 표준을 정하는 곳에서 각 문자에 해당하는 숫자값을 하나로 통일하자는 목적 아래 **ASCII**라는 표준을 만든다. (American Standard Code for Information Interchange 의 약자)
- 보통의 텍스트 파일을 주고 받을때 **ASCII**방식을 따르면 문제가 없지만, '바이너리'파일을 보낼 필요가 생긴다. 
- **바이너리**라는 단어가 **이진의**, **이진수의**라는 의미이다.
- 바이너리 파일은  음악, 그래픽, 동영상, 워드문서 파일등이다. 이들은 아스키 문자와 달리 8비트 데이터이다. (아스키는 7비트 데이타)
- 바이너리 파일을 전송할 때는 ASCII문자 파일로 변경해서 전달할 필요가 있다. (기존의 시스템상에서 문제없이 전달하기 위해서는 바이너리를 텍스트로 변환해야 했다.)
- 위의 변환을 인코딩이라 한다. 디코딩은 반대로 변환된 파일을 해독하는 것을 의미.
- **MIME**(Multipurpose Internet Mail Extensions) 일종의 인코딩 방식. 이메일을 보낼때 첨부파일을 텍스트 문자로 전환해서 이메일 시스템을 통해 전달하기 위해 개발되었고 현재는 웹을 통해 여러 형태의 파일을 전달하는데 사용되고 있다.
- MIME은 초기 UUEncode라는 인코딩에서 개선된 타입인데, 기존에 없었던 파일포맷이나 content-type의 정보등을 함께 담을 수 있다.
- MIME에서 사용하는 인코딩 방식을 **base64**라고 한다. 텍스트만 전달했던 기존 이메일 시스템에서도 바이너리 파일들을 자유롭게 주고 받을 수 있게 되었다.

### 번외2 : GET, POST의 차이

##### GET

**GET은 정보를 조회하기 위한 메소드**

GET은 URL의 끝에 `?`가 붙고 서버로 요청하려고 하는 파라미터가 이름과 값으로 붙게 된다. 파라미터가 여러개이면 `&`로 구분한다.

{% highlight html %}
www.naver.com/test?name1=value1&name2=value2
{% endhighlight %}

- URL에 요청 파라미터 추가하여 전송
- 대용량 데이터를 전송하기 힘들다
- 요청한 파라미터를 사용자가 눈으로 확인할 수 있다.

##### POST
**POST는 서버로 데이터를 전송할때 사용**

POST는 GET과 달리 파라미터가 URL에 붙여지지 않고 HTTP의 body에 담겨 파라미터를 전송하게 된다. 전송시 Content-Type에 데이터 타입을 추가해야 한다.

- 대용량 데이터를 전송할 때 사용.
- 전송 시 암호화 하여 사용하는것이 좋다.

##### 차이
GET과 POST는 설계방식이 달라서 주로 웹페이지를 읽을때에는 GET을 사용한다. POST의 경우 파라미터가 body에 있
기때문에 링크정보를 가져오기 힘들기 때문이다. 서버의 데이터를 변경시킬때 POST를 사용한다. GET, POST는 설계원칙에 따라 적절한 위치에서 알맞게 사용해야 한다.


###### 참고서적
> 그림으로 배우는 HTTP 네트워크 Basic